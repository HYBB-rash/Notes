# 关系数据库设计

通过设计满足适当的**范式**来是我们在存储信息时避免不必要的冗余，并且方便我们获取信息。

范式的设计实际时基于**函数依赖**的概念进行的。

## 好的关系设计的特点

首先假定我们有以下这些表和表的结构。

![SmartSelect_20200529-160308_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529160359.jpg)

### 设计选择：更大的模式

我们假设我们不再使用`instructor`和`department`表，而是用另一个模式代替：

![SmartSelect_20200529-160859_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529161012.jpg)

嗯，实际就是两个表连接嘛。

![SmartSelect_20200529-161111_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529161130.jpg)

我们看看用这张表会有什么缺陷。

首先，如果我们希望得到教师的基本信息，我们就不得不把`building`和`budget`两个字段都要显示一次，很容易我们就能发现这是没有必要的。

其次，`budget`属性明显冗余了，实际上只需要存储一个，但在这个表却存储了多个。

即使不考虑冗余问题，这个表也有潜在问题。如果我们需要添加一个新建立的系的新教师，这个系尚未有`building`和`budget`，那插入这个数据就不得不在这两个字段存`null`，我们一般时避免使用`null`值的，它总会造成一些奇怪的错误。使用原来的两张表的模式就不会有这个问题。

### 设计选择：更小的模式

再回到刚刚的例子：我们发现了数据冗余和一些操作上的不合适，我们需要把它分成两个表。那我怎么知道它就一定是要分成两个`instructor`和`budget`表呢？

虽然我们用眼睛发现了，如果这样设计表，会重复列出办公楼和预算导致重复。可是如果一旦数据体量变大，你的眼睛无法发现数据冗余，查重操作代价也异常的大，那该怎么办。

还有一种可能就是，即使发现了某个属性并不会重复，可这是不是只是一个特殊情况？是不是只是自己足够幸运，没有碰到重复的数据而已？怎么保证以后也不会出现重复的呢？

这个时候，我们需要通过**语义**来界定规则，来保证每个特定的值之多对应一个值，简单的说就是**根据现实情况指定规则**。在这个例子中，我们指定一个规则：如果存在模式(`dept_name`, `budget`)，则`dept_name`可以作为主码。
$$
dept\_name \to budget
$$
这条规则被定义为**函数依赖**。

我们基于函数依赖，制定了各种规范，使得能正确地分解成两个或者多个模式的情况。

但并不是所有所有的分解都是有益的。考虑下面的一个例子：

![SmartSelect_20200529-170824_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529170854.jpg)

分解成：

![SmartSelect_20200529-170917_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529171008.jpg)

考虑一个情况：一个公司里面会有两个同名的雇员。这是非常常见的现象。如果按照上面的设计，进行连接的时候，我们可以惊奇的发现：

![SmartSelect_20200529-171355_Xodo Docs](https://gitee.com/hybb0430/picture_bed/raw/master/img/20200529171416.jpg)

这个结果意料之外情理之中：多出了两条不对的数据。由于我们无法区分`Kim`对应的数据的情况，就出现了这个状况。我们称这种情况为**有损分解**，反之就叫做**无损分解**。

## 原子域和第一范式

原子域是指：域中的元素都是一个不可分割的元素。通俗点说，就是属性中每个元素都是一个数据，而不能是一个元组或者是一张表。

第一范式是指：所有的属性都是原子域的关系模式。

在现在的数据库中，只要是正常地建一个关系，那它一定就满足第一范式。

## 使用函数依赖进行分解

我们知道存在着一个规范方法来判断一个关系模式是否应该被分解，方法基于码和函数依赖的概念。我们接下来讨论怎么用函数依赖进行分解。

>   `F`集合指的是函数依赖集合。
>
>   `r`是关系，`R`是属性集，`r(R)`是一个关系模式。

### 码和函数依赖

虽然直接看数据，数据之间可能并不存在什么联系，但一旦与现实世界联系起来，数据就存在着各种约束。例如，一个大学的数据库应该有的一些约束：

1.  学生和教师都由唯一的一个`ID`进行标识。
2.  每个学生和教师都只有一个名字
3.  每个教师和学生都只能是一个系的学生（这里不考虑辅修）
4.  每个系都只有一个预算，且只拥有一个办公楼

一个关系模式满足这种现实世界约束的实例，称为关系的**合法实例**。几种常用的约束可以形式化成码和函数依赖。

复习一下超码的概念：超码可以是一个属性，也可以是多个属性的集合。它可以唯一地表示关系中的一条元组。

而函数依赖也有同样的作用：可以唯一标识某些属性的值的约束。

下面讲一讲函数依赖的概念：

考虑一个关系模式$r(R)$，令 $\alpha \subseteq R$ 且 $\beta \subseteq R$ 。

给定 $r(R)$ 一个实例，这个实例满足函数依赖 $\alpha \to \beta$ 的条件是：对实例中所有的元组 $t_1, t_2$ ，若 $t_1[\alpha] = t_2[\alpha]$ ，则 $t_1[\beta] = t_2[\beta]$ 。简单说就是每一个 $t[\alpha]$ 都有一个唯一对应的 $t[\beta]$ 。

如果实例中所有元素都符合函数依赖，我们认为该函数依赖成立。

并且， $\alpha$ 是该关系的超码。

有一种函数依赖叫做平凡函数依赖。这个东西很微妙。 $A \to A$ 就是一个平凡函数依赖。 $AB \to A$ 也是一个平凡函数依赖。一般来说，如果 $\beta \subseteq \alpha$，则类似于 $\alpha \to \beta$ 就是一个平凡函数依赖。

通过函数依赖集`F`，我们可能推导出某些其他的函数依赖。比如：
$$
A \to B, B \to C \Leftrightarrow A \to C
$$
简单说一下什么是闭包：在给定的函数集中，推导出所有其他的函数，再把它们放在一个集合中，叫做**闭包**。我们用 $F^+$ 来表示 $F$ 集合的闭包。

### Boyce-Codd 范式

我们较满意的一种范式是**Boyce-Codd 范式**（Boyce-Codd Normal Form，BCNF）。它消除所有基于函数依赖能够发现的冗余。

具有函数依赖集`F`的关系模式`R`属于`BCNF`的条件是：

对于 $F^+$ 中**所有**形如 $\alpha \to \beta$ 的函数依赖，下面至少一项成立：

1.   $\alpha \to \beta$ 是一个平凡函数依赖。
2.   $\alpha$ 是模式`R`的一个超码

分解成`BCNF`的一般规则：

1.   $\alpha \cup \beta$
2.   $(R - (\beta - \alpha))$

### BCNF和保持依赖

数据库是有许多约束的：主码约束，函数依赖，check约束，断言和触发器。每次更新数据时检查这些约束开销很大。如果函数依赖的检验只需要考虑一个关系就可以完成，那这样的约束开销很低。所以有些时候，`BCNF`的分解会妨碍某些函数依赖的高效检查。

我们常常希望我们能**保持依赖**，我们可以考虑一种比`BCNF`弱的范式，它允许我们保持依赖。它叫第三范式。

### 第三范式

第三范式`3NF`稍微放宽了`BCNF`的约束。

具有函数依赖集`F`的关系模式`R`属于`3NF`的条件是：

对于 $F^+$ 中**所有**形如 $\alpha \to \beta$ 的函数依赖，下面至少一项成立：

1.   $\alpha \to \beta$ 是一个平凡函数依赖。
2.   $\alpha$ 是模式`R`的一个超码
3.   $\beta - \alpha$ 中的每个属性`A`都包含于`R`的一个候选码中（`A`可能包含在不同的候选码中）

`3NF`放宽的是最后一个条件。`BCNF`一定属于`3NF`，它是更严厉的`3NF`。

条件3就是常见到的函数依赖问题，只不过这么些好理解一些，两者是等价的。

## 函数依赖理论

### 函数依赖集的闭包

### 属性集的闭包

### 正则覆盖

### 无损分解

### 保持依赖

## 分解算法

### BCNF分解

### 3NF分解

### 3NF算法的正确性

### BCNF和3NF的比较

## 使用多值依赖的分解

### 多值依赖

### 第四范式

### 4NF分解


# 大容量和高速度：开发存储器层次结构

## 引言

## 存储器技术

### SRAM技术

### DRAM技术

### 闪存

### 磁盘存储器

## cache的基本原理

### cache访问

### cache缺失处理

### 写操作处理

### 一个cache的例子：内置FastMATH处理器

### 小结

## cache性能的评估和改进

### 通过更灵活地放置块来减少cache缺失

### 在cache中查找一个块

### 替换块的选择

### 使用多级cache结构减少缺失代价

### 通过分块进行软件优化

### 总结

## 可信存储器层次

### 失效的定义

对于用户来说，一个系统在两种服务状态中反复横跳。

1. **服务实现**：服务结果与需求相同
2. **服务中断**：服务结果与需求不同

从状态1到状态2，我们称为失效；从状态2到状态1，我们称为恢复。

从这两个定义引出两个术语：可靠性和可用性

可靠性的度量方法：**MTTF，AFR**

#### MTTF

**mean time to feature**，平均无故障时间

#### AFR

**annual failure rate**，年失效率

### 纠正一位错，检测两位错的海明码

#### 一位错误检测编码

能检测出数据中有一位错误，但是不能确定错误位置，因此不能纠错。

#### 奇偶校验码

1. 奇偶校验码如何检错
	* 奇偶校验码计算数据中1的个数是奇数还是偶数。当一个字被写入后，奇偶校验码也被写入。1代表奇数，0代表偶数。
	* 读出数据时，只要计算奇偶校验位和实际的奇偶情况是否相同即可。
	* 其特点还有一个，写入一个校验位后不会影响其奇偶性
2. 奇偶校验码有缺陷
	* 出错的位数为偶数的时候，奇偶校验码无法检错。
	* 奇偶校验码是一位错误检测编码，只能检出一位错，且无法确定位置。

#### 汉明纠错码

##### 码距

两个等长的数据之间，不相同数据的位数。

* 举例：
	$$
	A = 1100 \\
	B = 1010 \\
	码距为2:A \space or \space B = 0110 \space （1的数量为2，所以码距为2
	$$

##### 步骤

见下图

![image-20200422090441840](https://raw.githubusercontent.com/HYBB-rash/cnBlogs/master/img/20200422090604.jpg)

1. 设置校验位，分别在$1, 2, 4, 8,\dots$即$2^n$的数据位设置校验位
	* 校验位的检测范围：请观察上图的规律。
	* 一般来说，校验码数据位的位置即表示检验的间隔。
	* 特殊点：数据位的位置是从1开始计算，但校验码的间隔是从0开始计算。所以第一个间隔要比正常间隔要少一位。
2. 检查检测范围内1的个数，若为奇数，检验位设置为1，反之设置为0
	* 通常是从$P1,P2,P4,P8\dots$的顺序进行设置，如果检测范围没有数字，则默认为0
3. 将所有校验位设置好后，海明码就设定完成

###### 纠错

接下来是看海明码怎么纠错

1. 从$P1,P2,P4,P8\dots$的顺序开始检查
2. 检查校验码范围内的1的个数，符合校验码的奇偶性则为正确，否则错误，记下哪个校验码出错
3. 将所有校验码检查过后，将所有出错校验码的权值相加，将对应位置的数据取反。
	* 例子：假如$P1,P8$出错，那出错位则为1+8=9，第九位出错，再将第九位取反，因为二进制出错只可能是取反了

###### 检错

海明码还可以检查两位错，通过再加一个校验位来校验**整个字符串奇偶性**。

1. 在最后一位添加一位奇偶校验位（P），用于校验整个数据的奇偶性，将检验位组成的数据称为（H）
2. 总共会有四种情况
	1. P为偶，H为偶：完全正确
	2. P为奇，H为奇：出现了一位可纠正的错
	3. P为偶，H为奇：说明H出错了，取反H
	4. P为奇，H为偶：出现了两位错

#### 循环冗余检验

[这里是参考的大神的blog，写得非常好，建议大家点这个传送门去仔细学习一下，下面关于CRC的内容几乎只是重新排版](https://blog.51cto.com/winda/1063951)

先在要发送的帧后面附加一个数，生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“**模2****除法**”）。到达接收端后，再把接收到的新帧除以（同样采用“**模2**除法**”），这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。

##### 模2除法

与我们平时做除法运算的过程类似，但运算过程中采用的是异或运算。

如100101除以1110，结果得到商为11，余数为1

![image-20200422100930848](https://raw.githubusercontent.com/HYBB-rash/cnBlogs/master/img/20200422101028.jpg)

如11×11=101

![160734195](https://raw.githubusercontent.com/HYBB-rash/cnBlogs/master/img/20200422101711.jpg)

##### 步骤

1. 先选择一个用于在接收端进行校验时，对接收的帧进行除法运算的除数（是二进制比较特串，通常是以多项方式表示，所以CRC又称多项式编码方法，这个多项式也称之为“生成多项式”）。
2. 看所选定的除数二进制位数（假设为k位），然后在要发送的数据帧（假设为m位）后面加上k-1位“0”，然后以这个加了k-1个“0“的新帧（一共是m+k-1位）以“模2除法”方式除以上面这个除数，所得到的余数（也是二进制的比特串）就是该帧的CRC校验码，也称之为FCS（帧校验序列）。但要注意的是，**余数的位数一定要是比除数位数只能少一位，哪怕前面位是****0****，甚至是全为0****（附带好整除时）也都不能省略**。
3. 再把这个校验码附加在原数据帧（就是m位的帧，注意不是在后面形成的m+k-1位的帧）后面，构建一个新帧发送到接收端；最后在接收端再把这个新帧以“模2除法”方式除以前面选择的除数，如果没有余数，则表明该帧在传输过程中没出错，否则出现了差错。

##### 实例

由以上分析可知，既然除数是随机，或者按标准选定的，所以CRC校验的关键是如何求出余数，也就是校验码（CRC校验码）。

下面以一个例子来具体说明整个过程。现假设选择的CRC生成多项式为G（X） = X4 + X3 + 1，要求出二进制序列10110011的CRC校验码。下面是具体的计算过程：

1. 首先把生成多项式转换成二进制数，由G（X） = X4 + X3 + 1可以知道（，它一共是5位（总位数等于最高位的幂次加1，即4+1=5），然后根据多项式各项的含义（多项式只列出二进制值为1的位，也就是这个二进制的第4位、第3位、第0位的二进制均为1，其它位均为0）很快就可得到它的二进制比特串为**11001**。

2. 因为生成多项式的位数为5，根据前面的介绍，得知CRC校验码的位数为4（校验码的位数比生成多项式的位数少1）。因为原数据帧10110011，在它后面再加4个0，得到10110011**0000**，然后把这个数以“模2除法”方式除以生成多项式，得到的余数（即CRC码）为**0100**，如图5-10所示。注意参考前面介绍的“模2除法”运算法则。

	![160749471](https://raw.githubusercontent.com/HYBB-rash/cnBlogs/master/img/20200422102152.jpg)

3. 把上步计算得到的CRC校验**0100**替换原始帧10110011**0000**后面的四个“0”，得到新帧10110011**0100**。再把这个新帧发送到接收端。

4. 当以上新帧到达接收端后，接收端会把这个新帧再用上面选定的除数**11001**以“模2除法”方式去除，验证余数是否为0，如果为0，则证明该帧数据在传输过程中没有出现差错，否则出现了差错。

## 虚拟机

### 虚拟机监视器的必备条件

### 指令集系统结构缺乏对虚拟机的支持

### 保护和指令集系统结构

## 虚拟存储器

### 页的存放和查找

### 缺页故障

### 关于写

### 加快地址转换：TLB

### 集成虚拟存储器，TLB和cache

### 虚拟存储器中保护

### 处理TLB缺失和缺页

### 小结




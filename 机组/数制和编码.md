# 数制和编码

## 进位计数制及其相互转换

### 进位计数制

- 二进制
	- 由于二进制书写起来及其不方便，因此人们大都用八进制和十六进制书写二进制数
- 八进制
- 十六进制
- 十进制

### 相互转换

#### 其他进制转10进制

- 二进制转十进制

	- 

		![img](https://img.mubu.com/document_image/7961ff65-f8e9-4dab-a3d3-bfed4e1bde26-5898337.jpg)

- 八进制转十进制

	- 

		![img](https://img.mubu.com/document_image/8dde5f16-2f9f-47e2-a7c4-6326ca22d8bd-5898337.jpg)

- 十六进制转十进制

	- 

		![img](https://img.mubu.com/document_image/733887bf-143f-4807-a0b2-e8834851f974-5898337.jpg)

#### 10进制转2进制

- 

	![img](https://img.mubu.com/document_image/52dbe560-42c8-443c-9820-63cc7dae3532-5898337.jpg)

#### 二进制转8，16进制

- 二进制转8进制

	- 

		![img](https://img.mubu.com/document_image/e67f4593-a290-44d4-b8f8-c953f1f12f46-5898337.jpg)

- 二进制转16进制

	- 

		![img](https://img.mubu.com/document_image/c5311b35-83f0-4c06-848a-44799b649de4-5898337.jpg)

#### 八，十六进制转二进制

- 与二进制转8，16进制十分类似，即反过程就是转换的做法

## 真值和机器数

- 真值：平常我们日常使用的有正负的数据
- 机器数：将真值数据化，即只用01来表示

## BCD码

### 定义

Binary code Decimal

二进制表示10进制的数据

### 8421码

- 用4位二进制码表示十进制的10个数

	![img](https://img.mubu.com/document_image/292d17a0-edff-4a9c-b23f-fc9df5bf0beb-5898337.jpg)

- 特殊情况

	- 给出的位数不是4的倍数

		![img](https://img.mubu.com/document_image/96d6cc95-31d3-44af-a519-345d263738f4-5898337.jpg)

### 余3码

#### 定义

在8421码的基础上，加上0011作为BCD码

为什么要加上0011

两个余三码相加的时候，余三码可以正常的产生进位信号

![img](https://img.mubu.com/document_image/ab743e04-4ea2-4ce4-8380-e38411cb898d-5898337.jpg)

但很明显，相加得出的结果只有进位信号是正确的，需要修正

- 进位成功

	- 加上一个0011

		![img](https://img.mubu.com/document_image/2ef41388-f4d3-45ff-a212-3eec7918d3cf-5898337.jpg)

- 进位失败

	- 减去一个0011

		![img](https://img.mubu.com/document_image/0cd531b8-0b1a-433e-9185-f27c3d1a6579-5898337.jpg)

- 2421码

	- 和8421码十分类似，只是最高位的权值被设定成了2

	- 为什么最高位要设定成2？

		可以方便运算，使得运算时的进位正常发生

		实际上为了进位方便，反而造成了许多不便……

		- 一个数字可能对应了2种码
			- 5可以由0101表示，也可以由1011表示
			- 为了解决这些矛盾，规定0101-1010区间的码不能使用
		- 规定了某些码不能使用，运算上又会出一些奇怪的问题
			- 比如4+3，我直接运算得出0111，但是它落在了禁用区间
			- 所以他还需要调整成到没被禁用的区间

		![img](https://img.mubu.com/document_image/0b66ca9c-2148-4b26-bd93-c2ba7d6c956c-5898337.jpg)

## 字符与字符串

### 字符编码ACSII

- 定义
	- 将各种符号以二进制的形式存储在计算机
- 需要记住的几个特别的acsii码
	- "A" = 81
	- "a" = 97
	- "0" = 48

### 汉字编码

### 字符串的大小端存放

## 校验码

### 定义

用来检查发送的数据是否正确

### 检错编码

可以检查出发送编码的错误，但不能纠正发送编码的错误

#### 奇偶校验码

##### 奇校验

添加一位校验码，使得1的总数是奇数

- 数据传输成功后
	- 若校验码1的总数是奇数，即没错
	- 否则则出现错误，打回重发

##### 偶校验

添加一位校验码，使得1的总数是偶数

- 数据传输成功后
	- 若校验码1的总数是偶数，即没错
	- 否则则出现错误，打回重发

##### 优点

实现简单，效率高，只需一个bit位

##### 缺点

- 检错率低，由于奇偶的性质，它只能检测出一半的错误

#### 循环冗余校验码

- 定义

#### 海明码

# 定点数的表示和运算

## 定点数的表示

### 无符号

指没有正负号的数据，直接用二进制表示

### 有符号

有正负号的数据

#### 表示方式：

- 原码
- 补码
- 反码

#### 三种码之间的关系和转化

##### first

- 首位都为符号位
- 可用 " , " 隔开符号位和整数
- 可用 " . " 隔开整数和小数点部分

##### second

- 它们都是以0作为正，1作为负

##### thirt

- 原码转换成反码是除了符号位按位取反
- 原码转换成反码是先转换成补码再加1
	- 反码转成原码操作也一样

#### 数据范围区别（假设8位，方便表达）

- 无符号
	- 0~255
- 有符号
	- -128~127
	- 有符号的数据范围不是对称的原因和补码有关
- 它们都能表达256个数，只是范围不同

#### 移码

##### 定义

- E(数据)-bias(偏移量)
- bias的大小一般由位数决定
	- 例如：8位的数据，偏移量则为128(2的7次方)
- 主要用途
	- 表示浮点数的阶码
	- 由于补码不方便比较大小，转化成移码后，可以方便进行比较大小

##### 如何获得移码

将补码的符号为取反即可

## 定点数的运算

### 计算机中采用补码来表示

#### 为什么不用原码

- 因为连基本的x+(-x)=0都做不到
- 存在正负零

#### 为什么不用反码

- 存在正负零

#### 为什么要用补码

- 它做到了x+(-x)=0
- 在补码中不存在正负零，不信你用0取反加一试试
- 运算时不用管符号位，直接运算即可
- 减法运算只需将数据取反加一得到相反数再相加即可，只需设计一个加法器
- 数位扩充只需补充符号位即可，而且这样做也不会影响数据的大小

### 浮点数的表示和运算

#### 浮点数的表示

##### IEEE 754标准

该标准是用科学计数法来表示浮点数

###### 公式

- $(-1)^S \times M \times 2^E$
- 符号(S)：代表数据的正负，1为负，0为正
- 阶码(E)：代表科学记数法使用的幂次
- 尾数(M)：代表小数点后的数据

###### 该标准对三种情况的定义

- 规格化的情况：阶码不全为0或者不全为1
	- 阶码使用移码来表示，即e=E-bias
	- 尾数暗藏有一个1，即m=M+1，记得M此时是小数
- 非规格化的情况：阶码全为0的情况
	- 阶码采用e=1-bias来表示
		- 为什么采用1-bias来表示
			- 当非规格化的值处于临界，即即将变成规格化的值时，能使其过渡十分平滑
	- 尾数此时没有隐藏的1，即m=M
- 特殊值：阶码全为1的情况
	- 若尾数为零
		- 此时表示无限大
	- 若尾数不为零
		- 此时表示NaN，即不存在这样的数

###### 这样设计的好处

- 浮点数将按顺序排列，它将同样适用于整数的排序函数而不需要另外编写

#### 浮点数的加/减法运算

# 算术逻辑单元

- ## 串行加法器和并行加法器

- ## 算术逻辑单元的功能和结构